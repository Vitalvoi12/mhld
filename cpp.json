{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Fenwick": {
	"prefix": "Fenwick",
	"body": [
		"struct Fenwick {",
		"    // 1 - индексация, отрезки",
		"    vector<int> t;",
		"    int n;",
		"    Fenwick(int a) {",
		"        n = a;",
		"        t.resize(a + 1);",
		"    }",
		"    int sum(int r) {",
		"        int res = 0;",
		"        for (; r > 0; r -= r & -r) {",
		"            res += t[r];",
		"        }",
		"        return res;",
		"    }",
		"    void add(int i, int x) {",
		"        for (; i <= n; i += i & -i) {",
		"            t[i] += x;",
		"        }",
		"    }",
		"    int sum(int l, int r) {",
		"        return sum(r) - sum(l - 1);",
		"    }",
		"    void chg(int i, int x) {",
		"        int delta = x - sum(i, i);",
		"        add(i, delta);",
		"    }",
		"    Fenwick(vector<int> &a) {",
		"        n = a.size();",
		"        t.resize(n + 1);",
		"        for (int i = 0; i < n; i++) {",
		"            add(i + 1, a[i]);",
		"        }",
		"    }",
		"};"
	],
	"description": "Fenwick"
	},
	"SegTree_min": {
	"prefix": "SegTree_min",
	"body": [
		"struct SegTree {",
		"    vector<int> t;",
		"    vector<int> a;",
		"    int n;",
		"    void build(int v, int l, int r) {",
		"        if (l + 1 == r) {",
		"            t[v] = a[l];",
		"            return;",
		"        }",
		"        int m = (r + l) / 2;",
		"        build(2 * v + 1, l, m);",
		"        build(2 * v + 2, m, r);",
		"        t[v] = max(t[2 * v + 1], t[2 * v + 2]);",
		"    }",
		"    SegTree(int m) {",
		"        n = m;",
		"        a = vector<int> (n, 0);",
		"        t.resize(4 * n);",
		"        build(0, 0, n);",
		"    }",
		"    SegTree(vector<int> &v) {",
		"        a = v;",
		"        n = v.size();",
		"        t.resize(4 * n);",
		"        build(0, 0, n);",
		"    }",
		"    void upd(int v, int l, int r, int pos, int x) {",
		"        if (l + 1 == r) {",
		"            t[v] = x;",
		"            return;",
		"        }",
		"        int m = (r + l) / 2;",
		"        if (pos < m) {",
		"            upd(2 * v + 1, l, m, pos, x);",
		"        } else {",
		"            upd(2 * v + 2, m, r, pos, x);",
		"        }",
		"        t[v] = max(t[2 * v + 1], t[2 * v + 2]);",
		"    }",
		"    int get(int v, int l, int r, int ql, int qr) {",
		"        if (l >= qr || r <= ql) return INT_MIN;",
		"        if (l >= ql && r <= qr) return t[v];",
		"        int m = (r + l) / 2;",
		"        return max(get(2 * v + 1, l, m, ql, qr), get(2 * v + 2, m, r, ql, qr));",
		"    }",
		"    int get(int l, int r) {",
		"        // полуинтервал, 0 индексация",
		"        return get(0, 0, n, l, r);",
		"    }",
		"    void upd(int pos, int x) {",
		"        upd(0, 0, n, pos, x);",
		"    }",
		"};"
	],
	"description": "SegTree_min"
	},
	"sparse_table": {
	"prefix": "sparse_table",
	"body": [
		"struct SparseTable {",
		"    int logn = 20;",
		"    vector<vector<int>> st;",
		"    int n;",
		"    SparseTable (vector<int> &a) {",
		"        n = a.size();",
		"        st.resize(logn, vector<int> (n));",
		"        for (int i = 0; i < n; i++) {",
		"            st[0][i] = a[i];",
		"        }",
		"        for (int l = 0; l < logn - 1; l++) {",
		"            for (int i = 0; (i + (1 << l)) < n; i++) {",
		"                st[l + 1][i] = min(st[l][i], st[l][i + (1 << l)]);",
		"            }",
		"        }",
		"    }",
		"    int rmq(int l, int r) {",
		"        // полуинтервал [l; r), 0 индексация",
		"        int k = __lg(r - l);",
		"        return min(st[k][l], st[k][r - (1 << k)]);",
		"    }",
		"};"
	],
	"description": "sparse_table"
	},
	"heavy_light_decomposition": {
	"prefix": "heavy_light_decomposition",
	"body": [
		"struct HLD {",
		"    vector<ll> tin;",
		"    vector<ll> tout;",
		"    vector<ll> head;",
		"    vector<ll> sz;",
		"    vector<ll> par;",
		"    vector<vector<ll>> g;",
		"    vector<ll> a;",
		"    Fenwick t;",
		"    ll n;",
		"    ll timer = 0;",
		"    void dfs(ll v, ll p) {",
		"        sz[v] = 1;",
		"        par[v] = p;",
		"        for (auto &to : g[v]) {",
		"            if (to == p) {",
		"                swap(to, g[v].back());",
		"                g[v].pop_back();",
		"                break;",
		"            }",
		"        }",
		"        for (ll u : g[v]) {",
		"            dfs(u, v);",
		"            sz[v] += sz[u];",
		"        }",
		"        for (ll &u : g[v]) {",
		"            if (sz[u] > sz[g[v][0]]) {",
		"                swap(u, g[v][0]);",
		"            }",
		"        }",
		"    }",
		"    void dfsHLD(ll v) {",
		"        tin[v] = timer++;",
		"        for (ll u : g[v]) {",
		"            if (u == g[v][0]) {",
		"                head[u] = head[v];",
		"            } else {",
		"                head[u] = u;",
		"            }",
		"            dfsHLD(u);",
		"        }",
		"        tout[v] = timer;",
		"    }",
		"    bool isa(ll a, ll b) {",
		"        return tin[a] <= tin[b] && tout[a] > tin[b];",
		"    }",
		"    void up(ll &v, ll &u, ll &ans) {",
		"        while (!isa(head[v], u)) {",
		"            ans += t.sum(tin[head[v]], tin[v]);",
		"            v = par[head[v]];",
		"        }",
		"    }",
		"    ll get(ll u, ll v) {",
		"        ll ans = 0;",
		"        up(u, v, ans);",
		"        up(v, u, ans);",
		"        ans += t.sum(min(tin[u], tin[v]), max(tin[u], tin[v]));",
		"        return ans;",
		"    }",
		"    HLD(vector<vector<ll>> &g2, vector<ll> &arr) {",
		"        g = g2;",
		"        n = arr.size();",
		"        tin.resize(n);",
		"        tout.resize(n);",
		"        sz.resize(n);",
		"        par.resize(n);",
		"        head.resize(n);",
		"        dfs(0, -1);",
		"        dfsHLD(0);",
		"        a.resize(n);",
		"        for (ll i = 0; i < n; i++) {",
		"            a[tin[i]] = arr[i];",
		"        }",
		"        t = Fenwick(a);",
		"    }",
		"};"
	],
	"description": "heavy_light_decomposition"
	}, 
	"includes": {
	"prefix": "includes",
	"body": [
		"#define _GLIBCXX_DEBUG",
		"#include <vector>",
		"#include <string>",
		"#include <iostream>",
		"#include <ext/pb_ds/assoc_container.hpp>",
		"#include <set>",
		"#include <map>",
		"#include <cmath>",
		"#include <iomanip>",
		"#include <climits>"
	],
	"description": "includes"
	}
}